/**
 * The color generator module.
 *
 * @author // TODO: Saskia Heinemannn <sh224wg@student.lnu.se>
 * @version 1.0.0
 */
const colorTemplate = document.createElement('template')
colorTemplate.innerHTML = `
<style>
    #container{
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 95%;
    }
    canvas{
      height:85%;
      width: 450px;
      padding:1%;
    }
    h4, p{
      text-align: center;
      line-height:0.1;

    }
   
    h4{
      margin-bottom: 0;
      margin-top:10px;
    }

    p{
      margin-bottom:10px;
      padding:1px;
    }
    
</style>
    <div id="container">
      <canvas id="myCanvas"></canvas>
      <h4> Click Anywhere To Begin</h4>
      <p id="colorName"></p>
    </div>
`
/**
 * `colorChange` is a custom HTML element that extends HTMLElement.
 * It is used to change the color of the element.
 *
 * @class
 */
class colorChange extends HTMLElement {
  /**
   * Constructs a new instance of the class and initializes the `isDrawing` property.
   */
  constructor () {
    super()
    this.isDrawing = false
  }

  /**
   * Invoked each time the custom element is appended into a document-connected element.
   * Sets up shadow DOM, initializes properties, and adds event listeners.
   *
   */
  connectedCallback () {
    this.attachShadow({ mode: 'open' }).appendChild(colorTemplate.content.cloneNode(true))
    this.container = this.shadowRoot.querySelector('#container')
    this.colorName = this.shadowRoot.querySelector('#colorName')
    this.canvas = this.shadowRoot.querySelector('#myCanvas')
    this.ctx = this.canvas.getContext('2d')

    this.radius = 1
    this.centerX = 0
    this.centerY = 0
    this.color = ''

    this.canvas.addEventListener('click', this.handleClick)
  }

  /**
   * Draws a circle on the canvas and increases its radius with each frame until it reaches the canvas's corner.
   * Once the circle's radius is larger than the distance to the corner, it stops drawing and adds a click listener.
   *
   */
  draw = () => {
    // create circle
    this.ctx.beginPath() // sets new path for drawing
    this.ctx.arc(this.centerX, this.centerY, this.radius, 0, 2 * Math.PI, false) // x and y are coordinates of arc cente, radius is the arc radius, circle, false clockwise
    this.ctx.fillStyle = this.color
    this.ctx.fill() // fills drawing path
    // increase radius of circle
    this.radius += 10

    // Calculate the distance from the center to a corner of the canvas
    const maxDistance = Math.sqrt(Math.pow(this.canvas.width, 2) + Math.pow(this.canvas.height, 2))

    // checks whether the radius of the circle is less than the maximum distance from the center of the canvas to a corner
    if (this.radius < maxDistance) {
      requestAnimationFrame(this.draw) // in progress draw
    } else {
      this.isDrawing = false // do not draw
      this.addClickListener()
    }
  }

  /**
   * Generates an array of 1000 unique random colors.
   * Each color is represented as a hexadecimal string in the format '#RRGGBB'.
   * The colors are generated by creating a random number between 0 and 16777215 (the decimal equivalent of 'FFFFFF' in hexadecimal).
   *
   * @returns {string[]} An array of 1000 unique random colors.
   */
  colorGenerator () {
    const colors = new Set()

    while (colors.size < 1000) {
      let randomColor = Math.floor(Math.random() * 16777215).toString(16) // (which is the decimal representation of the maximum value for a 24-bit color),
      // Pad the string with zeros until it's 6 characters long
      while (randomColor.length < 6) {
        randomColor = '0' + randomColor
      }
      randomColor = '#' + randomColor
      colors.add(randomColor)
    }
    return Array.from(colors)
  }

  /**
   * Handles a click event on the canvas.
   * If a drawing is in progress, it does nothing.
   * Otherwise, it starts a new drawing by selecting a random color, displaying the color name,
   * calculating the click position in canvas coordinates, and starting the drawing.
   * It also removes the click listener to prevent new drawings from starting before the current one is finished.
   *
   * @param {MouseEvent} e - The click event.
   */
  handleClick = (e) => {
    if (this.isDrawing) return
    this.isDrawing = true
    const colors = this.colorGenerator()
    this.color = colors[Math.floor(Math.random() * colors.length)] // select random color

    this.colorName.textContent = `Color: ${this.color}`
    // get top, left, right, bottom, width, height of canvas and positon relative to viewport
    const rect = this.canvas.getBoundingClientRect() // size of canvas and position rel to viewport
    // width and height of canvas in pixels / displayed width and height = scale from viewport to canvas
    const scaleX = this.canvas.width / rect.width
    const scaleY = this.canvas.height / rect.height
    // horizontal and vertical coordinate of mouseclick * canvas coordinates
    this.centerX = (e.clientX - rect.left) * scaleX
    this.centerY = (e.clientY - rect.top) * scaleY
    this.radius = 0
    this.canvas.removeEventListener('click', this.handleClick)
    this.draw()
  }

  /**
   * Adds a click event listener to the canvas.
   * The listener calls `handleClick` when the canvas is clicked.
   *
   */
  addClickListener = () => {
    this.canvas.addEventListener('click', this.handleClick.bind(this))
  }
}
customElements.define('color-change', colorChange)
